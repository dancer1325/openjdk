JEP 514: Ahead-of-Time Command-Line Ergonomics
======================================================================

| Owner | John Rose | 
| Type | Feature | 
| Scope | JDK | 
| Status | Closed / Delivered | 
| Release | 25 | 
| Component | hotspot / runtime | 
| Discussion | leyden dash dev at openjdk dot org | 
| Effort | M | 
| Duration | S | 
| Relates to | JEP 483: Ahead-of-Time Class Loading & Linking](483) | 
| Reviewed by | Alex Buckley, Vladimir Kozlov | 
| Endorsed by | Vladimir Kozlov | 
| Created | 2025/02/13 18:07 | 
| Updated | 2025/10/21 23:40 | 
| Issue | 8350022](https://bugs.openjdk.org/browse/JDK-8350022) | 

## Summary

Make it easier to createahead-of-time caches](https://openjdk.org/jeps/483), which accelerate the startup of Java applications, by simplifying the commands required for common use cases.

## Goals

- 
Simplify the process of creating an ahead-of-time (AOT) cache, with no loss of expressiveness.

- 
Do not introduce fundamentally new AOT workflows, but rather make it easier to access existing ones.

## Non-Goals

- It is not a goal to introduce new AOT optimizations; rather, we aim to simplify access to all AOT optimizations, both present and future.

## Motivation

Ahead-of-time caches, introduced byJEP 483](https://openjdk.org/jeps/483), accelerate the startup of Java applications. Their benefits are expected to grow asProject Leyden](https://openjdk.org/projects/leyden)brings new AOT-related optimizations to the HotSpot JVM.

With JDK 24, you create an AOT cache in two steps, invoking the`java`launcher in two distinct*AOT modes*. The first invocation specifies`record`mode, directing the JVM to observe the dynamics of a*training run*of your application and record them into an*AOT configuration*. The second invocation specifies`create`mode, directing the JVM to create an AOT cache based on the configuration recorded during the training run.

Here is an example of this two-step workflow, taken fromJEP 483](https://openjdk.org/jeps/483#Description):

```
$ java **-XX:AOTMode=record -XX:AOTConfiguration=app.aotconf** \
       -cp app.jar com.example.App ...

$ java **-XX:AOTMode=create -XX:AOTConfiguration=app.aotconf** \
       **-XX:AOTCache=app.aot**
```

Subsequently, you run your application specifying just the AOT cache:

```
$ java **-XX:AOTCache=app.aot** -cp app.jar com.example.App ...

```

This*production run*of the application starts more quickly because the application's classes do not need to be discovered, loaded, and linked. They are available instantly from the cache.

It is inconvenient to have to run`java`twice in order to create an AOT cache. It is also inconvenient to have the AOT configuration file left over â€” it is just a temporary file, not required for production runs, and can be deleted.

It would be far more convenient if, at least in common use cases, only one step were needed to perform a training run and create an AOT cache. This would be efficient for users and also convenient for applications such asJRuby](https://blog.headius.com/2025/02/boosting-jruby-startup-with-appcds-and-aotcache)that coordinate their own training against custom workloads. The ability to specify AOT modes and AOT configurations explicitly can remain for uncommon use cases.

## Description

We extend the`java`launcher with a new command-line option,`AOTCacheOutput`, that specifies an AOT cache output file. When used alone, with no other AOT options, this option causes the launcher to, in effect, split its invocation into two sub-invocations: The first does a training run (`AOTMode=record`) and then the second creates the AOT cache (`AOTMode=create`).

For example, the two-step workflow shown earlier can be replaced by the single step:

```
$ java **-XX:AOTCacheOutput=app.aot** -cp app.jar com.example.App ...

```

As a convenience, when operating in this way the JVM creates a temporary file for the AOT configuration and deletes the file when finished.

A production run that uses the AOT cache is started the same way as before:

```
$ java **-XX:AOTCache=app.aot** -cp app.jar com.example.App ...

```

A new environment variable,`JDK_AOT_VM_OPTIONS`, can be used to pass command-line options that apply specifically to the sub-invocation which performs cache creation, without affecting the sub-invocation which performs the training run. The syntax is the same as for the existing`JAVA_TOOL_OPTIONS`](https://docs.oracle.com/en/java/javase/24/docs/specs/jvmti.html#tooloptions)environment variable. This enables the one-step workflow to apply even in use cases where it might seem that the two-step workflow is necessary due to differences in the command-line options.

The full specification of these options is availablehere](https://bugs.openjdk.org/browse/JDK-8356010).

### Manually orchestrating training and cache creation

There are still use cases where it may be preferable to use the two-step workflow, specifying the AOT mode explicitly each time (`AOTMode=create`then`AOTMode=record`).

For example, if you intend to deploy an application to small instances in a cloud then you could do the training run on a small instance but create the AOT cache on a large instance. That way the training run reflects the deployment environment, but the creation of the AOT cache can leverage the additional CPU cores and memory of the large instance.

Such a division of labor may become more important as Leyden AOT optimizations become more complex. For example, some future AOT optimization might require minutes of time to create a cache on a small instance, but just seconds on a large instance.

In addition, the one-step workflow may not operate as expected in resource-constrained environments. The sub-invocation that creates the AOT cache uses its own Java heap with the same size as the heap used for the training run. As a result, the memory needed to complete the one-step workflow is double the heap size specified on the command line. For example, if the one-step workflow`java -XX:AOTCacheOutput=...`is accompanied by`-Xms4g -Xmx4g`, specifying a 4GB heap, then the environment needs 8GB to complete the workflow. Users in resource-constrained environments should use the two-step workflow if the one-step workflow does not complete successfully.

## Alternatives

- We considered a combined AOT mode,`AOTMode=record+create`. That could work today, but in the future we may extend training runs to read an existing AOT cache. At that point, the option`-XX:AOTCache=myapp.aot`would become ambiguous, and we would likely wind up introducing the`AOTCacheOutput`option anyway.