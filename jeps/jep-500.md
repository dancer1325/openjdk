JEP 500: Prepare to Make Final Mean Final
======================================================================

| Author | Ron Pressler & Alex Buckley | 
| Owner | Ron Pressler | 
| Type | Feature | 
| Scope | SE | 
| Status | Completed | 
| Release | 26 | 
| Component | core-libs | 
| Discussion | jdk dash dev at openjdk dot org | 
| Reviewed by | Alan Bateman, Brian Goetz | 
| Endorsed by | Mark Reinhold | 
| Created | 2025/02/06 10:25 | 
| Updated | 2025/12/15 16:35 | 
| Issue | 8349536](https://bugs.openjdk.org/browse/JDK-8349536) | 

## Summary

Issue warnings about uses of deep reflection to mutate final fields. These warnings aim to prepare developers for a future release that ensuresintegrity by default](https://openjdk.org/jeps/8305968)by restricting final field mutation, which will make Java programs safer and potentially faster. Application developers can avoid both current warnings and future restrictions by selectively enabling the ability to mutate final fields where essential.

## Goals

- 
Prepare the Java ecosystem for a future release that, by default, disallows the mutation of final fields by deep reflection. As of that release, application developers will have to explicitly enable the capability to do so at startup.

- 
Align final fields in normal classes with the implicitly declared fields ofrecord classes](https://openjdk.org/jeps/395), which cannot be mutated by deep reflection.

- 
Allow serialization libraries to continue working with`Serializable`classes, even classes with final fields.

## Non-Goals

- 
It is not a goal to deprecate or remove any part of the Java Platform API.

- 
It is not a goal to prevent the mutation of final fields by serialization libraries during deserialization.

## Motivation

Final fields represent immutable state. Once assigned in a constructor (for final instance fields) or in a class initializer (for static final fields), a final field cannot be reassigned. Its value, whether a primitive value or a reference to an object, is immutable. The expectation that a final field cannot be reassigned in far-flung parts of the program, whether deliberately or accidentally, is often crucial when reasoning about correctness.

The expectation that a final field cannot be reassigned is also important for performance. The more constraints there are on the behavior of a class, the more optimizations the JVM can apply. For example, being able to trust that final fields are never reassigned makes it possible for the JVM to perform*constant folding*](https://en.wikipedia.org/wiki/Constant_folding), an optimization that evaluates a constant expression just once rather than every time it is used. Constant folding is often the first step in a chain of optimizations that together can provide significant speedups.

Unfortunately, the expectation that a final field cannot be reassigned is false. The Java Platform includesseveral APIs](https://openjdk.org/jeps/8305968#Undermining-integrity)that allow final fields to be reassigned at any time by any code in a program, undermining all reasoning about correctness and invalidating important optimizations. The most prevalent of these is the*deep reflection*API embodied in the`setAccessible`](https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/Field.html#setAccessible(boolean))and`set`](https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/Field.html#set(java.lang.Object,java.lang.Object))methods of the`java.lang.reflect.Field`class. These methods allow you to mutate final fields at will. For example:

```
// A normal class with a final field
class C {
    final int x;
    C() { x = 100; }
}

// 1. Perform deep reflection over the final field in C
java.lang.reflect.Field f = C.class.getDeclaredField("x");
f.**setAccessible**(true);      // Make C's final field mutable

// 2. Create an instance of C
C obj = new C();
System.out.println(obj.x);  // Prints 100

// 3. Mutate the final field in the object
f.**set**(obj, 200);
System.out.println(obj.x);  // Prints 200
f.**set**(obj, 300);
System.out.println(obj.x);  // Prints 300

```

Final fields are, in reality, as mutable as non-final fields. We cannot rely on final fields to be immutable when reasoning about correctness, and we cannot use final fields to construct the deeply immutable graphs of objects that enable the JVM to deliver the best performance optimizations.

It might seem absurd that the Java Platform includes an API that undermines the meaning of the`final`keyword. Final fields have played a crucial role in theJava Memory Model](https://docs.oracle.com/javase/specs/jls/se24/html/jls-17.html#jls-17.4)since JDK 5; in particular, their immutability underpins thesafe initialization of objects](https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#finalWrong)in multi-threaded code. Unfortunately, their immutability alsoconflicts](https://bugs.openjdk.org/browse/JDK-5044412)with the operation of serialization libraries that mutate fields to initialize objects during deserialization. This use case was sufficiently important to justifychanging the reflection API](https://docs.oracle.com/javase/1.5.0/docs/api/java/lang/reflect/Field.html#set(java.lang.Object,%20java.lang.Object))in JDK 5 so that it could be used to mutate final fields.

In retrospect, offering such unconstrained functionality was a poor choice because it sacrificed integrity. When we introducedhidden classes](https://openjdk.org/jeps/371)in JDK 15 andrecord classes](https://openjdk.org/jeps/395)in JDK 16, we constrained deep reflection todisallow the mutation of final fields in hidden and record classes](https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/Field.html#set(java.lang.Object,java.lang.Object)). We constrained deep reflection further when westrongly encapsulated JDK internals](https://openjdk.org/jeps/403)in JDK 17. In JDK 24,we started the process](https://openjdk.org/jeps/498)to remove methods in`sun.misc.Unsafe`that, like deep reflection, allow the mutation of final fields.

Relatively little code mutates final fields, but the mere existence of APIs for doing so makes it impossible to trust the value of any final field. This compromises safety and performance in all programs. In line with the policy ofintegrity by default](https://openjdk.org/jeps/8305968), we propose to enforce the immutability of final fields so that, by default, code cannot use deep reflection to reassign them at will. We will support one special use case, namely serialization libraries that need to mutate final fields during deserialization, via a limited-purpose API.

## Description

In JDK 5 and later releases, you can mutate final fields via deep reflection, i.e., the`setAccessible`](https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/Field.html#setAccessible(boolean))and`set`](https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/Field.html#set(java.lang.Object,java.lang.Object))methods of`java.lang.reflect.Field`. In JDK 26, we will restrict deep reflection so that, by default, mutating a final field causes a warning to be issued at run time. It will not be possible to avoid the warning simply by using`--add-opens`to enable the deep reflection of classes with final fields.

We refer to restrictions on mutating final fields as*final field restrictions*. We will strengthen the effect of final field restrictions over time. Rather than issue warnings, a future JDK release will, by default, throw exceptions when Java code uses deep reflection to mutate final fields. This will enable the Java Platform and applications running on it to haveintegrity by default](https://openjdk.org/jeps/8305968). The warning we introduce here is intended to prepare developers for that future.

### Enabling final field mutation

Application developers can avoid warnings — and, in the future, exceptions — by enabling final field mutation for selected Java code on the command line or alternatives. Enabling final field mutation acknowledges the application's need to mutate final fields and lifts selected final field restrictions.

Under the policy ofintegrity by default](https://openjdk.org/jeps/8305968#Restrictions-on-standard-unsafe-APIs), it is the application developer — or perhaps deployer, on the advice of the application developer — who enables final field mutation, not library developers. Library developers who rely on reflection to mutate final fields should inform their users that they will need to enable final field mutation using one of the methods below.

To enable final field mutation by any code on the class path, regardless of where final fields are declared, use this command-line option:

```
$ java --enable-final-field-mutation=ALL-UNNAMED ...
```

To enable final field mutation by specific modules on the module path, again regardless of where final fields are declared, pass a comma-separated list of module names:

```
$ java --enable-final-field-mutation=M1,M2 ...
```

Enabling final field mutation for a module does not guarantee that code in the module will be able to perform deep reflection to mutate final fields. Any final field to be mutated must also be open to the code performing deep reflection, as detailedbelow](#The-deep-reflection-API).

Most application developers who wish to allow final field mutation will pass the`--enable-final-field-mutation`option directly to the`java`launcher in a startup script, but other techniques are available:

- 
You can pass`--enable-final-field-mutation`to the launcher indirectly, by setting the environment variable`JDK_JAVA_OPTIONS`.

- 
You can put`--enable-final-field-mutation`in an argument file that is passed to the launcher by a script or an end user, e.g.,`java @config`

- 
You can add`Enable-Final-Field-Mutation`to the manifest of an executable JAR file, i.e., a JAR file that is launched via`java -jar`](https://docs.oracle.com/en/java/javase/25/docs/specs/man/java.html#synopsis). (The only supported value for the`Enable-Final-Field-Mutation`manifest entry is`ALL-UNNAMED`; other values cause an exception to be thrown.)

- 
If you create a custom Java runtime for your application, you can pass the`--enable-final-field-mutation`option to`jlink`via the`--add-options`option, so that final field mutation is enabled in the resulting runtime image.

- 
TheJNI Invocation API](https://docs.oracle.com/en/java/javase/25/docs/specs/jni/invocation.html)allows a native application to embed a JVM in its own process. A native application which uses the JNI Invocation API can enable final field mutation for modules in the embedded JVM by passing the`--enable-final-field-mutation`option whencreating the JVM](https://docs.oracle.com/en/java/javase/25/docs/specs/jni/invocation.html#jni_createjavavm).

The`--enable-final-field-mutation`option can refer to modules in theboot module layer](https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ModuleLayer.html)only. It is not possible to enable final field mutation for code in user-defined layers.

### Controlling the effect of final field restrictions

It is illegal for code to mutate a final field via deep reflection if either the code is in a module for which final field mutation is not enabled, or the code is in a module to which the field's package is not open. What action the Java runtime takes when an illegal final field mutation is attempted is controlled by a new command-line option,`--illegal-final-field-mutation`. This option is similar in spirit and form to the`--illegal-access`option introduced byJEP 261](https://openjdk.org/jeps/261#Relaxed-strong-encapsulation)in JDK 9 and to`--illegal-native-access`introduced byJEP 472](https://openjdk.org/jeps/472)in JDK 24. It works as follows:

- 
`--illegal-final-field-mutation=allow`allows the mutation to proceed without warning.

- 
`--illegal-final-field-mutation=warn`allows the mutation but issues a warning the first time that code in a particular module performs an illegal final field mutation. At most one warning per module is issued.

This mode is the default in JDK 26. It will be phased out in a future release and, eventually, removed.

- 
`--illegal-final-field-mutation=debug`is identical to`warn`except both a warning message and a stack trace are issued for every illegal final field mutation.

- 
`--illegal-final-field-mutation=deny`will result in`Field::set`throwing an`IllegalAccessException`for every illegal final field mutation.

This mode will become the default in a future release.

When`deny`becomes the default mode,`allow`will be removed but`warn`and`debug`will remain supported for at least one release.

To prepare for the future, we recommend running existing code with the`deny`mode to identify code that mutates final fields via deep reflection.

### Warnings on the mutation of final fields

When code attempts an illegal final field mutation, the mutation will succeed but the Java runtime will, by default, issue a warning that identifies the caller:

```
WARNING: Final field f in p.C has been [mutated/unreflected for mutation] by class com.foo.Bar.caller in module N (file:/path/to/foo.jar)
WARNING: Use --enable-final-field-mutation=N to avoid a warning
WARNING: Mutating final fields will be blocked in a future release unless final field mutation is enabled
```

By default, at most one such warning is issued for any particular module, and only if a warning has not yet been issued for that module. The warning is written to the standard error stream.

### Identifying code that mutates final fields

Code that mutates final fields via deep reflection is usually library code, not application code. You can identify precisely which code mutates final fields by either:

- 
Starting the Java runtime with`--illegal-final-field-mutation=debug`, as describedabove](#Controlling-the-effect-of-final-field-restrictions), or

- 
Starting the Java runtime with JDK Flight Recorder (JFR) enabled. When JFR is enabled, the JVM records a`jdk.FinalFieldMutation`event whenever code mutates a final instance field or uses`Lookup.unreflectSetter`to get a`MethodHandle`with write access to a reflected final field. This event identifies the class declaring the final field, the name of the final field, and the stack trace to show where the final field mutation is coming from.

For example, here is how to create a JFR recording and then display the`jdk.FinalFieldMutation`events:

```
$ java -XX:StartFlightRecording:filename=recording.jfr ...
$ jfr print --events jdk.FinalFieldMutation recording.jfr
```

### The deep reflection API

The behavior of`Field::setAccessible`is unchanged. This means that when code calls`f.setAccessible(true)`on a`Field`object`f`, the code must either be in the same module as the field reflected by`f`, or, if the code is in a different module, the field reflected by`f`must be accessible to the caller via`exports`or`opens`. The call throws`InaccessibleObjectException`if these conditions are not met.

The behavior of`Field::set`is changed in JDK 26. If code calls`f.set(...)`on a`Field`object`f`, and the field reflected by`f`is final, then the field is mutated if:

- `f.setAccessible(true)`has already succeeded,
- the field's declaring class is in a package that is open to the caller's module, and
- final field mutation is enabled for the caller's module.

Conditions 2 and 3 are new in JDK 26. Their effect is:

- 
If final field mutation is not enabled for a module, and code in that module attempts to mutate any final field via deep reflection, an`IllegalAccessException`is thrown, unless suppressed by`--illegal-final-field-mutation`.

That is, given a`Field`object`f`that reflects a final field, it may be legal for code in the module to call`f.setAccessible(true)`but illegal for it to call`f.set(...)`.

- 
If final field mutation is enabled for a module, and code in that module attempts to mutate via deep reflection a final field in some package which is not open to the module, an`IllegalAccessException`is thrown, unless suppressed by`--illegal-final-field-mutation`.

This scenario can occur when code in one module, to which the field's package is open, calls`f.setAccessible(true)`and then passes`f`to code in a different module, for which final field mutation is enabled but to which the field's package is not open. It is illegal for the code that receives`f`to call`f.set(...)`.

The behaviors of related methods also change:

- 
The behavior of`MethodHandles.Lookup::unreflectSetter`](https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#unreflectSetter(java.lang.reflect.Field))is changed in the same way as`Field::set`.

- 
The`Module::addOpens`](https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Module.html#addOpens(java.lang.String,java.lang.Module))method allows a caller in module`M`to open a package in module`N`to another module`O`at run time, provided that the package is already open to`M`. If neither`M`nor`N`is enabled for final field mutation on the command line, the JVM will trust the final fields in the package. Subsequently, calling`addOpens`from`M`will not enable`O`to mutate final fields in the package. This applies even if`O`is enabled for final field mutation on the command line.

The same applies to`ModuleLayer.Controller::addOpens`](https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ModuleLayer.Controller.html#addOpens(java.lang.Module,java.lang.String,java.lang.Module))and`Instrumentation::redefineModule`](https://docs.oracle.com/en/java/javase/25/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#redefineModule(java.lang.Module,java.util.Set,java.util.Map,java.util.Map,java.util.Set,java.util.Map)).

- 
The`setIn`,`setOut`, and`setErr`methods](https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/System.html#method-detail)of the`java.lang.System`class exist to mutate, respectively, the final fields`in`,`out`, and`err`](https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/System.html#field-detail)of that class. These fields have always beenwrite-protected](https://docs.oracle.com/javase/specs/jls/se24/html/jls-17.html#jls-17.5.4), which means they can be mutated only by calling the corresponding methods. It has never been possible to mutate these fields via deep reflection. In JDK 26, there is no change of any kind to these fields and their corresponding methods.

Full details of the API changes are available in theCompatibility & Specification Review document](https://bugs.openjdk.org/browse/JDK-8353836).

### Serialization libraries should use`sun.reflect.ReflectionFactory`

The ability to mutate final fields via deep reflection was added in JDK 5 so that third-party serialization libraries could provide functionality on par with the JDK's own serialization facilities. The JDK can deserialize an object from an input stream even if the object's class declares final fields. It does this by bypassing the class's constructors, which ordinarily assign instance fields, andassigning values from the input stream to instance fields directly](https://docs.oracle.com/en/java/javase/25/docs/specs/serialization/input.html#the-objectinputstream-class)— even if they are final. Third-party serialization libraries use deep reflection to do the same.

When final field restrictions are strengthened in a future JDK release, serialization libraries will no longer be able to use deep reflection out-of-the-box. Rather than ask users to enable final field mutation on the command line, maintainers of serialization libraries should serialize and deserialize objects using the`sun.reflect.ReflectionFactory`](https://github.com/openjdk/jdk/blob/master/src/jdk.unsupported/share/classes/sun/reflect/ReflectionFactory.java)API, which issupported for this purpose](https://openjdk.org/jeps/260#Critical-internal-APIs-not-encapsulated-in-JDK-9). This API allows a serialization library to obtain amethod handle](https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/invoke/MethodHandle.html)to special code that initializes an object by assigning to its instance fields directly, including final fields. This code, which is dynamically generated by the JDK, gives the serialization library the same powers as the JDK's own serialization facilities; it is not necessary to enable final field mutation by the module of the serialization library.

The`sun.reflect.ReflectionFactory`class only supports the deserialization of objects whose classes implement the`java.io.Serializable`interface. This limitation balances the interests of developers using serialization libraries with the wider interest of all developers in having correct and efficient execution. It ensures that the JVM, when performing optimizations such as constant folding, is not unduly constrained in the assumptions it can make: It must assume that final fields in`Serializable`objects are potentially mutable, but it can also assume that final fields in all other objects — which are the vast majority — are permanently immutable.

If final field mutation is not enabled then`sun.reflect.ReflectionFactory`is the only mechanism that can mutate final fields. If the JVM detects that the method handle returned by the`ReflectionFactory`API for a particular class will not mutate final fields then it can treat the final fields in that class as permanently immutable. Fortunately, the JVM may be able do this for many JDK classes. For example, the JDK classes that implementunmodifiable lists](https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/List.html#unmodifiable)deserialize by invoking their constructors rather than by assigning to their instance fields. For these classes, the`ReflectionFactory`code could delegate to the classes' deserialization methods and thus avoid mutating final fields. Knowing this, the JVM could trust the final fields of every unmodifiable list, even for lists deserialized by a third-party library.

### Libraries should not use deep reflection to mutate final fields

Some libraries and frameworks for dependency injection, unit testing, and mockinguse deep reflection](https://openjdk.org/jeps/8305968#Restrictions-on-standard-unsafe-APIs)to manipulate objects, including by mutating final fields. The maintainers of such components should only ask users to enable final field mutation as a last resort. Instead, maintainers shouldfind architectural approaches](https://openjdk.org/jeps/8305968#Embracing-integrity-by-default)that avoid the need to mutate final fields or access private fields altogether. For example, most dependency injection frameworks now forbid the injection of final fields, and all discourage it, instead recommending constructor injection.

### Cloning should not use deep reflection

Authors of classes with final fields have long faced challenges implementing the`clone`](https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Object.html#clone())method. If an implementation of`clone`calls`super.clone()`then it cannot customize the values of final fields in the returned object simply by assigning to them. Implementations of`clone`sometimes use deep reflection to mutate these fields, but that will not work in a future JDK release that disallows the mutation of final fields by default.

Joshua Bloch's 2001 book*Effective Java*recommends avoiding`clone`and declaring static factory methods instead (Item 11: "Override`clone()`judiciously"). In a class that must continue to implement`clone`,`super.clone()`should be replaced with code that instantiates the class via a (possibly non-public) constructor. Because the constructor can initialize final fields to the desired values, the`clone`method need not use deep reflection.

### Mutating final fields from native code

Native code can mutate Java fields by calling the`Set<type>Field`functions](https://docs.oracle.com/en/java/javase/25/docs/specs/jni/functions.html#settypefield-routines)or the`SetStatic<type>Field`functions](https://docs.oracle.com/en/java/javase/25/docs/specs/jni/functions.html#setstatictypefield-routines)defined in theJava Native Interface](https://docs.oracle.com/en/java/javase/25/docs/specs/jni/index.html)(JNI).

The outcome of calling these functions on final fields isundefined behavior](https://en.wikipedia.org/wiki/Undefined_behavior). This means that Java constructs from which the program is built, such as objects, arrays, and types, no longer have integrity. The JVM can no longer guarantee that their behavior conforms to their specifications; for example, the program could access an array beyond its bound without the JVM raising an exception, resulting in memory corruption or a process crash. As we enhance the JVM's catalog of optimizations that exploit the final field restrictions placed on Java code, the chance of oddball outcomes due to undefined behavior in native code becomes more likely.

There are alreadyrestrictions on executing native code](https://openjdk.org/jeps/472)due to the possibility of undefined behavior, so by default the JVM can assume that these functions are not called. However, ifnative access is enabled](https://openjdk.org/jeps/472#Enabling-native-access), then we propose new diagnostics to mitigate the risks of oddball outcomes due to mutating final fields via JNI:

- 
If the application is started withunified logging](https://openjdk.org/jeps/158)enabled for native code (`-Xlog:jni=debug`), calling any of the JNI functions mentioned above on a final field will cause a message to be logged:

```
[0.20s][debug][jni] Set<type>Field of final instance field C.f
```

or

```
[0.20s][debug][jni] SetStatic<type>Field of final static field C.f
```

- 
If the application is started withadditional checking of JNI functions](https://docs.oracle.com/en/java/javase/25/docs/specs/man/java.html#extra-options-for-java)enabled (`-Xcheck:jni`), calling any of the JNI functions mentioned above on a final field will cause a warning to be printed.

In a future JDK release, we may change the JNI functions mentioned above so that they always return successfully when called on final fields, but never actually do any mutation.

There are no diagnostics for when Java code mutates final fields via the`sun.misc.Unsafe`API. Such mutations may violate integrity, and may cause strange bugs or JVM crashes. The process to remove the`sun.misc.Unsafe`methods that can be used to mutate final fieldswas begun in JDK 24](https://openjdk.org/jeps/498).

## Risks and Assumptions

- 
The ability to mutate final fields has been part of the Java Platform since JDK 5. There is a risk that existing applications will be impacted by the proposed final field restrictions.

- 
We assume that developers whose applications rely directly or indirectly on final field mutation will be able to configure the Java runtime to enable the capability via`--enable-final-field-mutation`. This is similar to how they can already configure the Java runtime to disable strong encapsulation for modules via`--add-opens`.

## Alternatives

- 
Rather than enforce the immutability of final fields, the Java runtime could rely on speculation: It could optimistically assume that final fields are not mutated, detect when they are, and then deoptimize code as necessary when that happens.

While speculative optimizations are the bread-and-butter of the JVM's JIT compiler, they may not suffice in this case. Future planned optimizations may rely not only on immutability within the lifetime of the process, but also on the immutability of fields from one run of the application to the next.

- 
Instead of specifying the modules whose code can mutate final fields, we could ask developers to specify the modules that allow their final fields to be mutated.

The mutation of final fields is undesirable, so it is best to record on the command line the modules whose code should be updated to no longer attempt mutation. Specifying instead the modules whose final fields can be mutated would not record why they allow their fields to be mutated, nor encourage libraries to migrate away from mutating those fields.

- 
We could require`--enable-final-field-mutation`to specify both the module performing the mutation and the modules containing the mutated fields.

This would be unnecessarily burdensome. In many practical cases,`--enable-final-field-mutation`will be specified in conjunction with`--add-opens`, which already specifies both parties to the use of deep reflection.