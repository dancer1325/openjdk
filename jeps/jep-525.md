JEP 525: Structured Concurrency (Sixth Preview)
======================================================================

| Authors | Alan Bateman, Viktor Klang, & Ron Pressler | 
| Owner | Alan Bateman | 
| Type | Feature | 
| Scope | SE | 
| Status | Completed | 
| Release | 26 | 
| Component | core-libs | 
| Discussion | loom dash dev at openjdk dot org | 
| Relates to | JEP 505: Structured Concurrency (Fifth Preview)](505) | 
| Reviewed by | Paul Sandoz | 
| Endorsed by | Paul Sandoz | 
| Created | 2025/09/04 12:43 | 
| Updated | 2025/11/19 08:13 | 
| Issue | 8366891](https://bugs.openjdk.org/browse/JDK-8366891) | 

## Summary

Simplify concurrent programming by introducing an API for*structured concurrency*. Structured concurrency treats groups of related tasks running in different threads as single units of work, thereby streamlining error handling and cancellation, improving reliability, and enhancing observability. This is apreview API](https://openjdk.org/jeps/12).

## History

Structured Concurrency incubated inJDK 19](https://openjdk.org/projects/jdk/19/)viaJEP 428](https://openjdk.org/jeps/428)andJDK 20](https://openjdk.org/projects/jdk/20/)viaJEP 437](https://openjdk.org/jeps/437). It previewed inJDK 21](https://openjdk.org/projects/jdk/21/)viaJEP 453](https://openjdk.org/jeps/453), with thefork](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable))method changed to return aSubtask](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.Subtask.html)rather than a`Future`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/Future.html). It re-previewed inJDK 22](https://openjdk.org/projects/jdk/22/)viaJEP 462](https://openjdk.org/jeps/462),JDK 23](https://openjdk.org/projects/jdk/23/)viaJEP 480](https://openjdk.org/jeps/480), andJDK 24](https://openjdk.org/projects/jdk/24/)viaJEP 499](https://openjdk.org/jeps/499). It re-previewed again inJDK 25](https://openjdk.org/projects/jdk/25/)viaJEP 505](https://openjdk.org/jeps/505)with several API changes; most notably, the public constructors of`StructuredTaskScope`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.html)were replaced with static factory methods.

We propose to preview the API once more in JDK 26 to allow further time for feedback. The changes for JDK 26 are minor:

- 
A new method in the`Joiner`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.Joiner.html)interface,`onTimeout()`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.Joiner.html#onTimeout()), allows implementations of that interface return a result when a timeout expires.

- 
`Joiner::allSuccessfulOrThrow()`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.Joiner.html#allSuccessfulOrThrow())now returns a list of results rather than a stream of subtasks.

- 
`Joiner::anySuccessfulResultOrThrow()`is now named`anySuccessfulOrThrow()`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.Joiner.html#anySuccessfulOrThrow()).

- 
The static`open`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.html#open(java.util.concurrent.StructuredTaskScope.Joiner,java.util.function.UnaryOperator))method that takes a`Joiner`and a function to modify the default configuration now takes a`UnaryOperator`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/function/UnaryOperator.html)instead of a`Function`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/function/Function.html).

## Goals

- 
Promote a style of concurrent programming that can eliminate common risks arising from cancellation and shutdown, such as thread leaks and cancellation delays.

- 
Improve the observability of concurrent code.

## Non-Goals

- 
It is not a goal to replace any of the concurrency constructs in the`java.util.concurrent`package, such as`ExecutorService`or`Future`.

- 
It is not a goal to create the definitive structured concurrency API for all Java programs. Other structured concurrency constructs can be defined by third-party libraries or in future JDK releases.

- 
It is not a goal to define a means of sharing streams of data among threads (i.e.,*channels](https://en.wikipedia.org/wiki/Channel_(programming))*). We might propose to do so in the future.

- 
It is not a goal to replace the existing thread interruption mechanism with a new thread cancellation mechanism. We might propose to do so in the future.

## Motivation

We manage complexity in programs by breaking tasks down into multiple subtasks. In ordinary single-threaded code, the subtasks execute sequentially. However, if the subtasks are sufficiently independent of each other, and if there are sufficient hardware resources, then the overall task can be made to run faster, i.e., with lower latency, by executing the subtasks concurrently. For example, a task that composes the results of multiple I/O operations will run faster if each I/O operation executes concurrently in its own thread. Virtual threads (JEP 444](https://openjdk.org/jeps/444)) make it cost-effective to dedicate a thread to every such I/O operation, but managing the huge number of threads that can result remains a challenge.

### Unstructured concurrency with`ExecutorService`

The`java.util.concurrent.ExecutorService`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/ExecutorService.html)API, introduced in Java 5, can execute subtasks concurrently.

For example, here is a method,`handle()`, that represents a task in a server application. It handles an incoming request by submitting two subtasks to an`ExecutorService`. One subtask executes the method`findUser()`, while the other executes the method`fetchOrder()`. The`ExecutorService`immediately returns a`Future`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/Future.html)for each subtask, and executes the subtasks concurrently according to its scheduling policy. The`handle()`method awaits the subtasks' results via blocking calls to their futures'`get()`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/Future.html#get())methods, so the task is said to*join*its subtasks.

```
Response handle() throws ExecutionException, InterruptedException {
    Future<String> user = executor.submit(() -> findUser());
    Future<Integer> order = executor.submit(() -> fetchOrder());
    String theUser = user.get();   // Join findUser
    int theOrder = order.get();    // Join fetchOrder
    return new Response(theUser, theOrder);
}
```

Because the subtasks execute concurrently, each subtask can succeed or fail independently. (Failure, in this context, means to throw an exception.) Often, a task such as`handle()`should fail if any of its subtasks fail. Understanding the lifetimes of the threads can be surprisingly complicated when failure occurs:

- 
If`findUser()`throws an exception then`handle()`will throw an exception when calling`user.get()`, but`fetchOrder()`will continue to run in its own thread. This is a*thread leak*which, at best, wastes resources; at worst, the`fetchOrder()`thread will interfere with other tasks.

- 
If the thread executing`handle()`is interrupted, the interruption will not propagate to the subtasks. Both the`findUser()`and`fetchOrder()`threads will leak, continuing to run even after`handle()`has failed.

- 
If`findUser()`takes a long time to execute, but`fetchOrder()`fails in the meantime, then`handle()`will wait unnecessarily for`findUser()`by blocking on`user.get()`rather than cancelling it. Only after`findUser()`completes and`user.get()`returns will`order.get()`throw an exception, causing`handle()`to fail.

In each case, the problem is that our program is logically structured with task-subtask relationships, but these relationships exist only in our minds.

This not only creates more room for error, but it makes diagnosing and troubleshooting such errors more difficult. Observability tools such as thread dumps, for example, will show`handle()`,`findUser()`, and`fetchOrder()`on the call stacks of unrelated threads, with no hint of the task-subtask relationship.

We might attempt to do better by explicitly cancelling other subtasks when an error occurs, for example by wrapping tasks with`try-finally`and calling the`cancel(boolean)`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/Future.html#cancel(boolean))methods of the futures of the other tasks in the catch block for the failing task. We would also need to use the`ExecutorService`inside a`try`-with-resources statement](https://docs.oracle.com/javase/specs/jls/se18/html/jls-14.html#jls-14.20.3), as shown in the examples inJEP 444](https://openjdk.org/jeps/444#Using-virtual-threads-vs--platform-threads), because`Future`does not offer a way to wait for a task that has been cancelled. But all this keeping track of the inter-task relationships can be tricky to get right, and it often makes the logical intent of the code harder to discern.

This need to manually coordinate lifetimes is due to the fact that`ExecutorService`and`Future`allow unrestricted patterns of concurrency. There are no constraints upon, or ordering of, any of the threads involved. One thread can create an`ExecutorService`, a second thread can submit work to it, and the threads which execute the work have no relationship to either the first or second thread. Moreover, after a thread has submitted work, a completely different thread can await the results of execution. Any code with a reference to a`Future`can join it, i.e., await its result by calling`get()`— even code in a thread other than the one which obtained the`Future`. In effect, a subtask started by one task does not have to return to the task that submitted it. It could return to any of a number of tasks — or possibly none.

Because`ExecutorService`and`Future`allow for such unstructured use, they do not enforce or even track relationships among tasks and subtasks, even though such relationships are common and useful. Accordingly, even when subtasks are submitted and joined in the same task, the failure of one subtask cannot automatically cause the cancellation of another: In the above`handle()`method, the failure of`fetchOrder()`cannot automatically cause the cancellation of`findUser()`. The future for`fetchOrder()`is unrelated to the future for`findUser()`, and neither is related to the thread that will ultimately join it via its`get()`method.

Rather than manage such cancellation manually, we should aim to reliably automate it.

### Task structure should reflect code structure

In contrast to the freewheeling assortment of threads under`ExecutorService`, the execution of single-threaded code always enforces a hierarchy of tasks and subtasks. The body block`{...}`of a method corresponds to a task, and the methods invoked within the block correspond to subtasks. An invoked method must either return to, or throw an exception to, the method that invoked it. An invoked method cannot outlive the method that invoked it, nor can it return to or throw an exception to a different method. Thus all subtasks finish before the task, each subtask is a child of its parent, and the lifetime of each subtask relative to the others and to the task is governed by the syntactic block structure of the code.

For example, in this single-threaded version of`handle()`, the task-subtask relationship is apparent from the syntactic structure:

```
Response handle() throws IOException {
    String theUser = findUser();
    int theOrder = fetchOrder();
    return new Response(theUser, theOrder);
}
```

We do not start the`fetchOrder()`subtask until the`findUser()`subtask has completed, whether successfully or unsuccessfully. If`findUser()`fails then we do not start`fetchOrder()`at all, and the`handle()`task fails implicitly. The fact that a subtask can return only to its parent is significant: It implies that the parent task can implicitly treat the failure of one subtask as a trigger to cancel other unfinished subtasks and then fail itself.

In single-threaded code, the task-subtask hierarchy is reified in the call stack at run time. We thus get the corresponding parent-child relationships, which govern error propagation, for free. When observing a single thread, the hierarchical relationship is obvious:`findUser()`, and later`fetchOrder()`, appear subordinate to`handle()`. This makes it easy to answer the question, "what is`handle()`working on now?"

Concurrent programming would be easier, more reliable, and more observable if the parent-child relationships between tasks and their subtasks were evident from the syntactic structure of the code and also reified at run time — just as for single-threaded code. The syntactic structure would delineate the lifetimes of subtasks and enable a runtime representation of the inter-thread hierarchy, analogous to the intra-thread call stack. That representation would enable error propagation and cancellation as well as meaningful observation of the concurrent program.

(The Java Platform already has an API for imposing structure on concurrent tasks, namely`java.util.concurrent.ForkJoinPool`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/ForkJoinPool.html), which is the execution engine behind parallel streams. However, that API is designed for compute-intensive tasks rather than tasks which involve I/O.)

### Structured concurrency

*Structured concurrency*is an approach to concurrent programming that preserves the natural relationship between tasks and subtasks, which leads to more readable, maintainable, and reliable concurrent code. The term "structured concurrency" was coined byMartin Sústrik](https://web.archive.org/web/20250530113135/https://250bpm.com/blog:71)and popularized byNathaniel J. Smith](https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/). Ideas from other languages, such as Erlang's hierarchical supervisors, inform the design of error handling in structured concurrency.

Structured concurrency derives from a simple principle: If a task splits into concurrent subtasks then they all return to the same place, namely the task's code block.

In structured concurrency, subtasks work on behalf of a task. The task awaits the subtasks' results and monitors them for failures. As with structured programming techniques for code in a single thread, the power of structured concurrency for multiple threads comes from two ideas: The flow of execution through a block of code has well-defined entry and exit points, and the lifetimes of operations are nested in a way that mirrors their syntactic nesting in the code.

Because the entry and exit points of a block of code are well defined, the lifetime of a concurrent subtask is confined to the syntactic block of its parent task. Because the lifetimes of sibling subtasks are nested within that of their parent task, they can be reasoned about and managed as a unit. Because the lifetime of the parent task is, in turn, nested within that of its parent, the runtime can reify the hierarchy of tasks into a tree that is the concurrent counterpart of the call stack of a single thread. This allows policies, such as deadlines, to be applied to entire sub-trees of tasks, and allows observability tools to present subtasks as subordinate to their parent tasks.

Structured concurrency is a great match forvirtual threads](https://openjdk.org/jeps/444), which are lightweight threads implemented by the JDK. Virtual threads share operating-system threads, allowing for enormous numbers of virtual threads. In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior, even behavior that involves I/O. This means that a server application can use structured concurrency to process thousands or millions of incoming requests at once: It can dedicate a new virtual thread to the task of handling each request, and when a task fans out by submitting subtasks for concurrent execution then it can dedicate a new virtual thread to each subtask. Behind the scenes, the task-subtask relationship is reified into a tree by arranging for each virtual thread to carry a reference to its unique parent, similar to how a frame in the call stack refers to its unique caller.

In summary, virtual threads deliver an abundance of threads. Structured concurrency can correctly and robustly coordinate them, and enables observability tools to display threads as they are understood by developers. Having an API for structured concurrency in the Java Platform would make it easier to build maintainable, reliable, and observable server applications.

## Description

The principal class of the structured concurrency API is`StructuredTaskScope`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.html), in the`java.util.concurrent`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/package-summary.html)package. This class allows us to structure a task as a family of concurrent subtasks, and to coordinate them as a unit. Subtasks are executed in their own threads by*forking*them individually and then*joining*them as a unit.`StructuredTaskScope`confines the lifetimes of the subtasks to a clearlexical scope](https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scope)in which all of a task's interactions with its subtasks — forking, joining, handling errors, and composing results — takes place.

Here is the`handle()`example from earlier, revised to use`StructuredTaskScope`:

```
Response handle() throws InterruptedException {

    try (var scope = StructuredTaskScope.open()) {

        Subtask<String> user = scope.fork(() -> findUser());
        Subtask<Integer> order = scope.fork(() -> fetchOrder());

        scope.join();   // Join subtasks, propagating exceptions

        // Both subtasks have succeeded, so compose their results
        return new Response(user.get(), order.get());

    }

}
```

In contrast to the original example, understanding the lifetimes of the threads involved here is easy: Under all conditions, their lifetimes are confined to a lexical scope, namely the body of the`try`-with-resources statement. Furthermore, the use of`StructuredTaskScope`ensures a number of valuable properties:

- 
*Error handling with short-circuiting*— If one of the`findUser()`or`fetchOrder()`subtasks fails, by throwing an exception, then the other is cancelled, i.e.,interrupted](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/lang/Thread.html#interrupt()), if it has not yet completed.

- 
*Cancellation propagation*— If the thread running`handle()`is interrupted before or during the call to`join()`, then both subtasks are cancelled automatically when the thread exits the scope.

- 
*Clarity*— The above code has a clear structure: Set up the subtasks, wait for them to either complete or be cancelled, and then decide whether to succeed (and process the results of the child tasks, which are already finished) or fail (and the subtasks are already finished, so there is nothing more to clean up).

- 
*Observability*— A thread dump, as describedbelow](#Observability), clearly displays the task hierarchy, with the threads running`findUser()`and`fetchOrder()`shown as children of the scope.

### StructuredTaskScope is apreview API](https://openjdk.org/jeps/12), disabled by default

To use the`StructuredTaskScope`API you must enable preview APIs, as follows:

- 
Compile the program with`javac --release 26 --enable-preview Main.java`and run it with`java --enable-preview Main`; or,

- 
When using thesource code launcher](https://openjdk.org/jeps/330), run the program with`java--enable-previewMain.java`; or,

- 
When usingjshell](https://openjdk.org/jeps/222), start it with`jshell --enable-preview`.

### Using`StructuredTaskScope`

The`StructuredTaskScope<T, R>`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.html)API, where`T`is the result type of tasks forked in the scope and`R`is the result type of the`join`method, can be summarized as:

```
public sealed interface StructuredTaskScope<T, R> extends AutoCloseable {

    public static <T> StructuredTaskScope<T, Void> open();
    public static <T, R> StructuredTaskScope<T, R> open(Joiner<? super T,
                                                               ? extends R> joiner);

    public <U extends T> Subtask<U> fork(Callable<? extends U> task);
    public Subtask<? extends T> fork(Runnable task);

    public R join() throws InterruptedException;

    public void close();

}
```

The general workflow of code using`StructuredTaskScope`is:

- 
Open a new scope by calling one of the static`open`methods. The thread that opens the scope is the scope's*owner*.

- 
Use the`fork`methods to fork subtasks in the scope.

- 
Use the`join`method to join all of the scope's subtasks, as a unit. This may throw an exception.

- 
Process the outcome.

- 
Close the scope, usually implicitly via`try`-with-resources. This cancels the scope, if it is not already cancelled, thereby cancelling all of its remaining subtasks and waiting for them to terminate.

In the`handle()`example, the zero-parameter`open()`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.html#open())factory method creates and opens a`StructuredTaskScope`that implements the default*completion policy*, which is to fail if any subtask fails. Other policies can be implemented, as we shall seebelow](#Joiners), by passing a suitable`Joiner`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.Joiner.html)to the one-parameter`open`method.

Each call to a`fork`method starts a thread to execute a subtask, which by default is a virtual thread. A subtask can create its own`StructuredTaskScope`to fork its own subtasks, thus creating a hierarchy of scopes. That hierarchy is reflected in the code's block structure, which confines the lifetimes of the subtasks: All of the subtasks' threads are guaranteed to have terminated once the scope is closed, and no thread is left behind when the block exits.

The`join`method must be called by the scope's owner thread from within the scope. If a scope's block exits before joining then the scope is cancelled and the owner will wait in the`close`method for all subtasks to terminate before throwing an exception.

After joining, the scope's owner can process the results of the subtasks using the`Subtask`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.Subtask.html)objects returned from the`fork`methods. The`Subtask::get`method throws an exception if called before joining.

### Cancellation

A scope's owner thread may be interrupted either before or while joining. For example, the owner could itself be a subtask of an enclosing scope that has been cancelled. If this occurs then`join()`will throw an exception because there is no point in continuing. The`try`-with-resources statement will then cancel the scope, which will cancel all the subtasks and wait for them to terminate. This has the effect of automatically propagating the cancellation of the task to its subtasks.

To allow for cancellation, subtasks must be coded so that they finish as soon as possible wheninterrupted](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/lang/Thread.html#interrupt()). Subtasks that do not respond to interrupts because, e.g., they block on methods that are not interruptible, may delay the closing of a scope indefinitely. The`close`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.html#close())method always waits for threads executing subtasks to finish, even if the scope is cancelled. Execution cannot continue beyond the`close`method until the interrupted threads finish.

### Scoped values

Subtasks forked in a scope inherit`ScopedValue`bindings (JEP 487](https://openjdk.org/jeps/487#Inheriting-scoped-values)). If a scope's owner reads a value from a bound`ScopedValue`then each subtask will read the same value.

### Structured use is enforced

At run time,`StructuredTaskScope`enforces structure and order upon concurrent operations. For example, attempts to call a`fork`method from a thread that is not the scope's owner will fail with an exception. Using a scope outside of a`try`-with-resources block and returning without calling`close()`, or without maintaining the proper nesting of`close()`calls, may cause the scope's methods to throw a`StructureViolationException`.

`StructuredTaskScope`does not implement the`ExecutorService`or`Executor`interfaces, since instances of those interfaces are commonly used in a non-structured way (seebelow](#Alternatives)). However, it is straightforward to migrate code that uses`ExecutorService`, but would benefit from structure, to use`StructuredTaskScope`.

### Joiners

In the`handle()`example, if any subtask fails then the`join`method throws an exception and the scope is cancelled. If all subtasks succeed then the`join`method completes normally and returns`null`. This is the default completion policy.

Other policies can be selected by creating a`StructuredTaskScope`with a suitable`StructuredTaskScope.Joiner`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.Joiner.html). A`Joiner`object handles subtask completion and produces the outcome for the`join`method. Depending on the joiner, the`join`method may return a result, a list of elements, or some other object.

The`Joiner`interface declares factory methods to create joiners for some common cases. For example, the factory method`anySuccessfulOrThrow()`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.Joiner.html#anySuccessfulOrThrow())returns a new joiner that yields the result of any subtask that completes successfully:

```
<T> T race(Collection<Callable<T>> tasks) throws InterruptedException {
    try (var scope = StructuredTaskScope.open(Joiner.<T>anySuccessfulOrThrow())) {
        tasks.forEach(scope::fork);
        return scope.join();
    }
}
```

As soon as one subtask succeeds then the scope is cancelled, cancelling the unfinished subtasks, and`join()`returns the result of the successful subtask. If all subtasks fail then`join()`throws a`FailedException`with the exception from one of the subtasks as thecause](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/lang/Throwable.html#getCause()). This pattern can be useful in, e.g., server applications that require a result from any one of a collection of redundant services.

The factory method`allSuccessfulOrThrow()`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.Joiner.html#allSuccessfulOrThrow())returns a new joiner that, when all subtasks complete successfully, yields a list of their results:

```
<T> List<T> runConcurrently(Collection<Callable<T>> tasks) throws InterruptedException {
    try (var scope = StructuredTaskScope.open(Joiner.<T>allSuccessfulOrThrow())) {
        tasks.forEach(scope::fork);
        return scope.join();
    }
}
```

If one or more subtasks fail then`join()`throws a`FailedException`with the exception from one of the failed subtasks as the cause. The completion policy implemented by the`Joiner`is the same as the default policy implemented by the zero-parameter`open()`method. They differ in outcome in that the`join`method returns a list of results rather than`null`, making this joiner suited for cases where all subtasks return a result of the same type and where the`Subtask`objects returned by the`fork`method is ignored.

The`Joiner`interface declares three additional factory methods:

- 
`awaitAll()`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.Joiner.html#awaitAll()), which returns a new joiner that simply waits for all subtasks to complete, whether successfully or not;

- 
`awaitAllSuccessfulOrThrow()`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.Joiner.html#awaitAllSuccessfulOrThrow()), which returns a new joiner that waits for all subtasks to complete successfully; and

- 
`allUntil(Predicate<Subtask<T>> isDone)`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.Joiner.html#allUntil(java.util.function.Predicate)), which returns a new joiner that, when all subtasks complete successfully or else a predicate on a completed subtask returns`true`, cancels the enclosing scope and yields a list of all the subtasks.

When using any kind of`Joiner`, it is critical to create a new`Joiner`for each`StructuredTaskScope`.`Joiner`objects should never be used in different task scopes or re-used after a scope is closed.

### Custom Joiners

The`Joiner`interface can be implemented directly in order to support custom completion policies. It has two type parameters:`T`for the result type of the subtasks executed in the scope, and`R`for the result type of the`join`method. The interface can be summarized as:

```
public interface Joiner<T, R> {
    public default boolean onFork(Subtask<T> subtask);
    public default boolean onComplete(Subtask<T> subtask);
    public void onTimeout();
    public R result() throws Throwable;
}
```

The`onFork`method is invoked when forking a subtask, while the`onComplete`method is invoked when a subtask completes. Both methods return a`boolean`to indicate whether the scope should be cancelled. The`onTimeout`method is invoked if the scope is opened with a timeout and the timeout expires before, or while waiting in, the`join`method. The`result`method is invoked to produce the result for the`join`method, or else throw an exception, when all subtasks have completed or the scope is cancelled. If the`result`method throws an exception then the`join`method will throw a`FailedException`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.FailedException.html)with that exception as the cause.

Here is a`Joiner`class that collects the results of subtasks that complete successfully, ignoring subtasks that fail. The`onComplete`method may be invoked by several threads concurrently, and so must be thread-safe. The`result`method returns a list of the task results.

```
class CollectingJoiner<T> implements Joiner<T, List<T>> {

    private final Queue<T> results = new ConcurrentLinkedQueue<>();

    public boolean onComplete(Subtask<T> subtask) {
        if (subtask.state() == Subtask.State.SUCCESS) {
            results.add(subtask.get());
        }
        return false;
    }

    public List<T> result() {
        return List.copyOf(results);
    }

}
```

This custom policy can be used like so:

```
<T> List<T> allSuccessful(List<Callable<T>> tasks) throws InterruptedException {
      try (var scope = StructuredTaskScope.open(new CollectingJoiner<T>())) {
          tasks.forEach(scope::fork);
          return scope.join();
      }
  }
```

### Exception handling

How exceptions are handled will depend on usage. The`join`method throws a`FailedException`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.FailedException.html)when the scope is considered to have failed. In the`handle()`example, if a subtask fails then a`FailedException`is thrown with the exception from the failed subtask as the cause. In some cases it may be useful to add a`catch`block to the`try`-with-resources statement in order to handle exceptions after the scope is closed:

```
try (var scope = StructuredTaskScope.open()) {
   ...
} catch (StructuredTaskScope.FailedException e) {
   Throwable cause = e.getCause();
   switch (cause) {
       case IOException ioe -> ..
       default -> ..
   }
}
```

Exception-handling code can use the`instanceof`operator with pattern matching (JEP 394](https://openjdk.org/jeps/394)) to handle specific causes.

A specific exception in a subtask may trigger the return of a default value. In such cases it may be more appropriate to catch the exception in the subtask and have it complete with the default value as the result rather than have the scope's owner handle the exception.

### Configuration

Theearlier summary](#Using-StructuredTaskScope)of the`StructuredTaskScope`API showed two static`open`methods. Athird such method](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.html#open(java.util.concurrent.StructuredTaskScope.Joiner,java.util.function.UnaryOperator))accepts a`Joiner`together with an operator that can modify the defaultconfiguration object](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.Configuration.html)in order to set the scope's name for monitoring and management purposes, to set the scope's timeout, and to set thethread factory](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/ThreadFactory.html)to be used by the scope's`fork`methods to create threads,

Here is a revised version of the`runConcurrently`method which sets a thread factory and a timeout:

```
<T> List<T> runConcurrently(Collection<Callable<T>> tasks,
                            ThreadFactory factory,
                            Duration timeout)
    throws InterruptedException
{
    try (var scope = StructuredTaskScope.open(Joiner.<T>allSuccessfulOrThrow(),
                                              cf -> cf.withThreadFactory(factory)
                                                      .withTimeout(timeout))) {
        tasks.forEach(scope::fork);
        return scope.join();
    }
}
```

The`fork`method in this scope will invoke the given thread factory to create the thread to execute each subtask. This can be useful to, e.g., set the thread's name or other properties.

The`timeout`is specified as a`java.time.Duration`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/time/Duration.html). In this example, if the timeout expires before or while waiting in`join()`then the scope is cancelled, which cancels all incomplete subtasks, and`join()`throws a`TimeoutException`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/StructuredTaskScope.TimeoutException.html).

### Observability

We extend the JSON thread-dump formatadded for virtual threads](https://openjdk.org/jeps/444#Observing-virtual-threads)to show how`StructuredTaskScope`s group threads into a hierarchy:

```
$ jcmd <pid> Thread.dump_to_file -format=json <file>
```

The JSON object for each scope contains an array of the threads forked in the scope, together with their stack traces. The owner thread of a scope will typically be blocked in a`join`method, waiting for subtasks to complete; the thread dump makes it easy to see what the subtasks' threads are doing by showing the tree hierarchy imposed by structured concurrency. The JSON object for a scope also has a reference to its parent, so that the structure of the program can be reconstituted from the dump.

The`com.sun.management.HotSpotDiagnosticsMXBean`](https://cr.openjdk.org/~alanb/sc-jdk26/api/jdk.management/com/sun/management/HotSpotDiagnosticMXBean.html#dumpThreads(java.lang.String,com.sun.management.HotSpotDiagnosticMXBean.ThreadDumpFormat))API can also be used to generate such thread dumps, either directly or indirectly via the platform`MBeanServer`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.management/javax/management/MBeanServer.html)and a local or remote JMX tool.

## Alternatives

### Enhance the`ExecutorService`interface

We prototyped an implementation of this interface that always enforces structure and restricts which threads can submit tasks. However, we found it to be problematic because most uses of`ExecutorService`, and its parent interface`Executor`, in the JDK and in the ecosystem are not structured. Reusing the same API for a far more restricted concept is bound to cause confusion. For example, passing a structured`ExecutorService`instance to existing methods that accept this type would be all but certain to throw exceptions in most situations.

### Have the`fork`methods return a`Future`

When the`StructuredTaskScope`API was incubating, the`fork`methods returned a`Future`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/Future.html). This provided a sense of familiarity, by making these methods resemble the existing`ExecutorService::submit`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable))method. However, the fact that`StructuredTaskScope`is intended to be used in a structured way, while`ExecutorService`is not, brought more confusion than clarity.

- 
The familiar use of`Future`involves calling its`get()`method, which blocks until a result is available. But in the context of`StructuredTaskScope`, using`Future`in this way is not only discouraged, but counterproductive. Structured`Future`objects should be queried only after the`join`method returns, at which point they are known to be completed, and the method that should be used is not the familiar`get()`method but rather the recently introduced`resultNow()`](https://cr.openjdk.org/~alanb/sc-jdk26/api/java.base/java/util/concurrent/Future.html#resultNow())method, which does not block.

- 
Some developers wondered why the`fork`methods did not return more capable`CompletableFuture`objects. Since the`Future`returned by these methods should only be used after they are known to have completed,`CompletableFuture`would have offered no benefit since its advanced features are helpful only for uncompleted futures. In addition,`CompletableFuture`is designed for the asynchronous programming paradigm, whereas`StructuredTaskScope`encourages the blocking paradigm.

`Future`and`CompletableFuture`are, in short, designed to offer degrees of freedom that are counterproductive in structured concurrency.

- 
Structured concurrency is about treating related tasks running in different threads as a single unit of work, whereas`Future`is mostly useful when treating multiple tasks as individual tasks. A scope should block only once to await its subtasks' results, and it should then process exceptions centrally. In the vast majority of cases, therefore, the only method that should be called on a`Future`returned from a`fork`method was`resultNow`. This was a marked change from the ordinary use of`Future`, and the`Future`interface served as a distraction from its proper use in this context.

In the current API,`Subtask::get()`behaves exactly as`Future::resultNow()`did when the API was incubating.